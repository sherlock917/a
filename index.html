<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>algorithm</title>
  <style>
  h3 {
    cursor: pointer;
  }
  h6 {
    color: red;
  }
  pre {
    padding: 10px;
    border: 1px solid #333;
    overflow: auto;
  }
  </style>
</head>
<body style="background: white; font-family: Helvetica">

  <h6>点击标题显示代码</h6>

  <div>
    <h3>8594 有重复元素的排列问题</h3>
    <pre style="display: none;">
#include <iostream>

using namespace std;

static int counter = 0;

void mSwap (char &a, char &b) {
    char tmp = a;
    a = b;
    b = tmp;
}

bool mFind (char list[], int start, int end) {
    for (int i = start; i <= end - 1; i++) {
        if (list[i] == list[end]) {
            return true;
        }
    }
    return false;
}

void mPerm (char list[], int k, int m) {
    if (k == m) {
        for (int i = 0; i <= m; i++) {
            cout << list[i];
        }
        cout << endl;
        counter++;
    } else {
        for (int i = k; i <= m; i++) {
            if (mFind(list, k, i)) {
                continue;
            }
            mSwap(list[k], list[i]);
            mPerm(list, k + 1, m);
            mSwap(list[k], list[i]);
        }
    }
}

int main(int argc, const char * argv[]) {
    
    int length;
    char list[20];
    
    cin >> length;
    cin >> list;
    
    mPerm(list, 0, length - 1);
    cout << counter << endl;
    
    
    return 0;
}
    </pre>
  </div>

  <div>
    <h3>9718 整数因子分解</h3>
    <pre style="display: none;">
#include <iostream>

using namespace std;

int counter = 1;

void divider (int num) {
    for(int i = num - 1; i > 1; i--) {
        if (num % i == 0) {
            counter++;
            divider(num / i);
        }
    }
}

int main(int argc, const char * argv[]) {
    
    int num;
    cin >> num;
    divider(num);
    cout << counter << endl;
    return 0;
    
}
    </pre>
  </div>

  <div>
    <h3>11088 整数划分的扩展问题</h3>
    <pre style="display: none;">
#include <iostream>

using namespace std;

int Q(int n, int m);
int EVEN(int n, int m);
int ODD(int n, int m);

// 最大加数不超过m的划分数；不超过m个正整数之和的划分数
int Q(int n, int m){
    if((n < 1) || (m < 1)){
        return 0;
    }
    
    if((n == 1) || (m == 1)){
        return 1;
    }
    
    if(n < m){
        return Q(n, n);
    }
    
    if(n == m){
        return Q(n, m-1) + 1;
    }
    
    return Q(n, m-1) + Q(n-m, m);
}

// 正偶整数之和的划分数
int EVEN(int n, int m){
    if(m > n || m <= 0){
        return 0;
    }
    
    if(((n == 1) && (m == 1)) || ((n == 2) && (m == 2))){
        return 0;
    }
    
    if((n == 2) && (m == 1)){
        return 1;
    }
    
    return ODD(n-m, m);
}

// 正奇整数之和的划分数
int ODD(int n, int m){
    if(m > n || m <= 0){
        return 0;
    }
    
    if((n == 2) && (m == 1)){
        return 0;
    }
    
    if(((n == 1) && (m == 1)) || ((n == 2) && (m == 2))){
        return 1;
    }
    
    return ODD(n-1, m-1) + EVEN(n-m, m);
}

int main()
{
    int n,m;
    cin >> n;
    cin >> m;
    
    int res1 = Q(n,m);//（1）（2）问答案相同
    int res2 = 0;//（3）（4）问答案相同
    for(int i=1;i<=n;i++){
        res2 += ODD(n,i);
    }
    
    cout << res1 << " " << res1 << " " << res2 << " " << res2;
    
    cout << endl;
    return 0;
}
    </pre>
  </div>

  <div>
    <h3>17082 两个有序数序列中找第k小</h3>
    <pre style="display: none;">
#include <iostream>

using namespace std;

int m,n,k;

int find (int X[], int m, int Y[], int n, int k) {
    int temp = 0, xBeg = 0, xEnd = 0, yBeg = 0, yEnd = 0, xMid = 0, yMid = 0;
    xBeg = yBeg = 0;
    xEnd  = m - 1;
    yEnd = n - 1;
    
    while (xBeg <= xEnd && yBeg <= yEnd) {
        xMid = (xBeg + xEnd) /2;
        yMid = (yBeg + yEnd) /2;
        
        temp = (xMid - xBeg + 1) + (yMid - yBeg + 1);
        
        if(X[xMid] > Y[yMid]) {
            if(temp > k) {
                xEnd = xMid - 1;
            }
            else {
                k = k - (yMid - yBeg + 1);
                yBeg = yMid + 1;
            }
        } else {
            if(temp > k) {
                yEnd = yMid - 1;
            } else {
                k = k - (xMid - xBeg + 1);
                xBeg = xMid + 1;
            }
        }
    }
    
    if(xBeg > xEnd) {
        return Y[yBeg + k - 1];
    }
    else {
        return X[xBeg + k - 1];
    }
}

int main(int argc, const char * argv[]) {
    
    cin >> m;
    cin >> n;
    cin >> k;
    
    int X[m];
    int Y[n];
    
    for (int i = 0; i < m; i++) {
        cin >> X[i];
    }
    
    for (int i = 0; i < n; i++) {
        cin >> Y[i];
    }
    
    cout << find(X, m, Y, n, k) << endl;
}
    </pre>
  </div>

  <div>
    <h3>8596 最长上升子序列</h3>
    <pre style="display: none;">
#include<iostream>

using namespace std;

int n;
int a[501];

int f[501];
int c[100];
int num=0;

int main()
{
    while(true)
    {
        a[0]=-1;
        cin >>n;
        if(n==0)
            break;                             //输入停止条件
        
        for(int i=1; i<=n; i++)
            cin>>a[i];
        
        for(int i=1; i<=n; i++)
        {
            f[i]=1;                           //初始化，单个元素作为一个队列时，长度都为1
            int big=0;
            for(int j=1; j< i; j++)
                if(a[j]< a[i])
                    if(big< f[j])
                        big=f[j];            //找出a[i]之前的字串中比a[i]值小且其递增子串队列长度最大的队列，
            //将子串队列长度赋值给big
            
            f[i]=big+1;                //big为找到的最优子串的长度，+1是加上a[i]本身长度
        }
        int max=f[1];
        //数组f中已经存放数组a的不同递增子串长度，遍历数组f，找出最大值
        for(int i=1; i<=n; i++)
            if(max< f[i])
                max=f[i];
        c[num++]=max;
        
    }
    for(int i=0; i< num; i++)
        cout << c[i]<< endl;
}
    </pre>
  </div>

  <div>
    <h3>8601 最大长方体问题</h3>
    <pre style="display: none;">
#include<iostream>

using namespace std;

int max(int i,int j)
{
    if(i>=j)
        return i;
    else
        return j;
}

int MSum(int *a,int n)
{
    int sum=0;
    int b[50];
    b[0]=a[0];
    for(int i=1;i< n;i++)
    {
        b[i]=max(b[i-1]+a[i],a[i]);
        if(b[i]>sum)
            sum=b[i];
    }
    return sum;
}

int MSum2(int a[][50],int m,int n)
{
    int sum=0;
    int b[50],k;
    for(int i=0;i< m;i++)
    {
        for(k=0;k< n;k++)
            b[k]=0;
        for(int j=i;j< m;j++)
        {
            for(k=0;k< n;k++)
                b[k]+=a[j][k];
            sum=max(sum,MSum(b,n));
        }
    }
    return sum;
}

int MSum3(int a[][50][50],int m,int n,int p)
{
    int sum=0;
    int b[50][50],k,i,j,z,x;
    for(i=0;i< p;i++)
    {
        for(z=0;z< m;z++)
            for(x=0;x< n;x++)
                b[z][x]=0;
        
        for(int j=i;j< p;j++)
        {
            for(z=0;z< m;z++)
                for(x=0;x< n;x++)
                    b[z][x]+=a[z][x][j];
            sum=max(sum,MSum2(b,m,n));
        }
    }
    return sum;
}


int main()
{
    int a[50][50][50],m,n,p;
    cin>>m>>n>>p;
    for(int i=0;i< m;i++)
        for(int j=0;j< n;j++)
            for(int k=0;k< p;k++)
                cin>>a[i][j][k];
    cout<< MSum3(a,m,n,p)<< endl;
    
    return 0;
}
    </pre>
  </div>

  <div>
    <h3>10303 数字三角</h3>
    <pre style="display: none;">
#include <iostream>
#include <string>

using namespace std;

// 将int类型转为string的函数
string int2str(int n) {
    char t[24];
    char tran_t[24];
    int i = 0;
    while (n) {
        t[i++] = (n % 10) + '0';
        n /= 10;
    }
    t[i] = 0;
    //转置，提交系统不支持char转置的库函数
    int j = 0;
    while(i) {
        tran_t[j++] = t[--i];
    }
    tran_t[j] = 0;
    return string(tran_t);
}

// 求max的函数
int max(int a, int b) {
    return a > b ? a : b;
}

// 求最大路径的函数
void maxPath(int num[101][101], int n, int m[101][101], string path[101][101]) {
    for(int i = n; i >= 1; i --) {
        for(int j = 1; j <= i; j ++) {
            if(i == n) {
                m[i][j] = num[i][j];
                path[i][j] = int2str(num[i][j]);
            } else {
                int maxNum = max(m[i + 1][j], m[i + 1][j + 1]);
                m[i][j] = maxNum + num[i][j];
                string tmp = maxNum == m[i + 1][j + 1] ? path[i + 1][j + 1] : path[i + 1][j];
                path[i][j] = int2str(num[i][j]) + " " + tmp;
            }
        }
    }
}

int main() {
    int n = 0; // 三角形的行数
    int num[101][101]; // 存放三角形中数的二维数组
    int m[101][101]; // 记录最优值的二维数组
    string path[101][101]; // 记录路径的数组
    std::cin >> n;
    if(1 <= n && n <= 100) {
        // 初始化数塔
        for(int i = 1; i <= n; i ++) {
            for(int j = 1; j <= i; j ++) {
                std::cin >> num[i][j];
                path[i][j] = "";
            }
        }
        maxPath(num,n,m,path);
        std::cout << m[1][1] << endl;
        std::cout << path[1][1];
    }
    return 0;
}
    </pre>
  </div>

  <div>
    <h3>11077 最长公共子字符串</h3>
    <pre style="display: none;">
#include <iostream>
#include <string.h>

using namespace std;

int c[10000][10000];
char str1[10000];
char str2[10000];

void find (long m,long n) {
    if (m < 0 || n < 0 ) {
        return;
    }

    for (int i = 0; i < m; i++) {
        for(int j = 0; j < n; j++) {
            c[i][j] = 0;
        }
    }

    int besti = 0, bestj = 0;
    int count = 0;

    for (int i = 0; i < m; i++) {
        for (int j=0; j < n; j++) {
            if (str1[i] == str2[j]) {
                if( i == 0 || j == 0) {
                    c[i][j]=1;
                } else {
                    c[i][j]=c[i-1][j-1] + 1 ;
                }
            } else {
                c[i][j]=0;
            }
        }
    }

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (c[i][j] > count) {
                count = c[i][j];
                besti = i;
                bestj = j;
            }
        }
    }

    cout << count << endl;

    if (count == 0) {
        cout << endl;
    } else {
        for(int i= besti - count + 1; i <= besti; i++) {
            cout << str1[i];
        }
        cout << endl;
    }
}

int main () {

    long m = 0, n = 0;
    cin >> str1;
    cin >> str2;
    m = strlen(str1);
    n = strlen(str2);
    find(m,n);

}
    </pre>
  </div>

  <div>
    <h3>11078 不能移动的石子合并</h3>
    <pre style="display: none;">
#include<iostream>

using namespace std;

int n,minnum,maxnum;
int m[100][100],p[100],sum[100];
int maxs[100][100],mins[100][100];

int min(int i,int j)
{
    if(i<=j)
        return i;
    else
        return j;
}

int max(int i,int j)
{
    if(i>=j)
        return i;
    else
        return j;
}

int sums(int i,int j)
{
    if(i+j>=n)
        return sums(i,n-i-1)+sums(0,(i+j)%n);
    else
        return sum[i+j]-(i>0?sum[i-1]:0);
}

void minLine()
{
    int i,j,k,r,t,stonesum;
    for(i=1;i<=n;i++)
        m[i][i]=0;
    for( r=2;r<=n;r++)
    {

        for(i=1;i<=n-r+1;i++)
        {
            j=i+r-1;

            m[i][j]=100000;

            if(i>1)
                stonesum=sum[j]-sum[i-1];
            else
                stonesum=sum[j];

            for(k=i;k< j;k++)
            {
                t=m[i][k]+m[k+1][j]+stonesum;

                if(t< m[i][j])
                {
                    m[i][j]=t;
                }
            }
        }
    }
}

void maxLine()
{
    int i,j,k,r,t,stonesum;
    for(i=1;i<=n;i++)
        m[i][i]=0;
    for(r=2;r<=n;r++)
    {
        for(i=1;i<=n-r+1;i++)
        {
            j=i+r-1;

            m[i][j]=0;

            if(i>1)
                stonesum=sum[j]-sum[i-1];
            else
                stonesum=sum[j];

            for( k=i;k< j;k++)
            {
                t=m[i][k]+m[k+1][j]+stonesum;

                if(t>m[i][j])
                {
                    m[i][j]=t;
                }
            }
        }
    }
}

void countLoop()
{
    int i,j,k;
    for(i=0;i< n;i++)
        mins[i][0]=maxs[i][0]=0;

    for(j=1;j< n;j++)
    {
        for(i=0;i< n;i++)
        {
            mins[i][j]=100000;
            maxs[i][j]=0;
            for(k=0;k< j;k++)
            {
                mins[i][j]=min(mins[i][k]+mins[(i+k+1)%n][j-k-1]+sums(i,j),mins[i][j]);

                maxs[i][j]=max(maxs[i][k]+maxs[(i+k+1)%n][j-k-1]+sums(i,j),maxs[i][j]);
            }
        }

    }

    minnum=mins[0][n-1];
    maxnum=maxs[0][n-1];

    for(i=0;i< n;i++)
    {
        minnum=min(minnum,mins[i][n-1]);
        maxnum=max(maxnum,maxs[i][n-1]);
    }
}

int main()
{
    int i;
    cin>>n;
    for(i=1;i<=n;i++)
        cin>>p[i];

    sum[1]=p[1];
    for(i=2;i<=n;i++)
        sum[i]=sum[i-1]+p[i];

    minLine();
    cout<< m[1][n]<< " ";
    maxLine();
    cout<< m[1][n]<< endl;


    for(i=0;i< n;i++)
        p[i]=p[i+1];

    sum[0]=p[0];
    for(i=1;i< n;i++)
        sum[i]=sum[i-1]+p[i];

    countLoop();
    cout<< minnum<<" "<< maxnum<< endl;

    return 0;
}
    </pre>
  </div>

  <script>
  (function () {
    var titles = document.getElementsByTagName('h3');
    var codes = document.getElementsByTagName('pre');

    for (var i = 0; i < titles.length; i++) {
      (function () {
        var j = i;
        titles[j].onclick = function (e) {
          if (codes[j].style.display == 'none') {
            codes[j].style.display = 'block';
          } else {
            codes[j].style.display = 'none';
          }
        }
      })();
    }

    for (var i = 0; i < codes.length; i++) {
      (function () {
        var j = i;
        codes[j].ondblclick = function (e) {
          codes[j].style.display = 'none';
        }
      })();
    }
  })();
  </script>

</body>
</html>