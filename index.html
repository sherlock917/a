<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>algorithm</title>
  <style>
  h3 {
    cursor: pointer;
  }
  h6 {
    color: red;
  }
  pre {
    padding: 10px;
    border: 1px solid #333;
    overflow: auto;
  }
  </style>
</head>
<body style="background: white; font-family: Helvetica">

  <h6>点击标题显示代码</h6>

  <div>
    <h3>8594 有重复元素的排列问题</h3>
    <pre style="display: none;">
#include <iostream>

using namespace std;

static int counter = 0;

void mSwap (char &a, char &b) {
    char tmp = a;
    a = b;
    b = tmp;
}

bool mFind (char list[], int start, int end) {
    for (int i = start; i <= end - 1; i++) {
        if (list[i] == list[end]) {
            return true;
        }
    }
    return false;
}

void mPerm (char list[], int k, int m) {
    if (k == m) {
        for (int i = 0; i <= m; i++) {
            cout << list[i];
        }
        cout << endl;
        counter++;
    } else {
        for (int i = k; i <= m; i++) {
            if (mFind(list, k, i)) {
                continue;
            }
            mSwap(list[k], list[i]);
            mPerm(list, k + 1, m);
            mSwap(list[k], list[i]);
        }
    }
}

int main(int argc, const char * argv[]) {
    
    int length;
    char list[20];
    
    cin >> length;
    cin >> list;
    
    mPerm(list, 0, length - 1);
    cout << counter << endl;
    
    
    return 0;
}
    </pre>
  </div>

  <div>
    <h3>9718 整数因子分解</h3>
    <pre style="display: none;">
#include <iostream>

using namespace std;

int counter = 1;

void divider (int num) {
    for(int i = num - 1; i > 1; i--) {
        if (num % i == 0) {
            counter++;
            divider(num / i);
        }
    }
}

int main(int argc, const char * argv[]) {
    
    int num;
    cin >> num;
    divider(num);
    cout << counter << endl;
    return 0;
    
}
    </pre>
  </div>

  <div>
    <h3>11088 整数划分的扩展问题</h3>
    <pre style="display: none;">
#include <iostream>

using namespace std;

int Q(int n, int m);
int EVEN(int n, int m);
int ODD(int n, int m);

// 最大加数不超过m的划分数；不超过m个正整数之和的划分数
int Q(int n, int m){
    if((n < 1) || (m < 1)){
        return 0;
    }
    
    if((n == 1) || (m == 1)){
        return 1;
    }
    
    if(n < m){
        return Q(n, n);
    }
    
    if(n == m){
        return Q(n, m-1) + 1;
    }
    
    return Q(n, m-1) + Q(n-m, m);
}

// 正偶整数之和的划分数
int EVEN(int n, int m){
    if(m > n || m <= 0){
        return 0;
    }
    
    if(((n == 1) && (m == 1)) || ((n == 2) && (m == 2))){
        return 0;
    }
    
    if((n == 2) && (m == 1)){
        return 1;
    }
    
    return ODD(n-m, m);
}

// 正奇整数之和的划分数
int ODD(int n, int m){
    if(m > n || m <= 0){
        return 0;
    }
    
    if((n == 2) && (m == 1)){
        return 0;
    }
    
    if(((n == 1) && (m == 1)) || ((n == 2) && (m == 2))){
        return 1;
    }
    
    return ODD(n-1, m-1) + EVEN(n-m, m);
}

int main()
{
    int n,m;
    cin >> n;
    cin >> m;
    
    int res1 = Q(n,m);//（1）（2）问答案相同
    int res2 = 0;//（3）（4）问答案相同
    for(int i=1;i<=n;i++){
        res2 += ODD(n,i);
    }
    
    cout << res1 << " " << res1 << " " << res2 << " " << res2;
    
    cout << endl;
    return 0;
}
    </pre>
  </div>

  <div>
    <h3>17082 两个有序数序列中找第k小</h3>
    <pre style="display: none;">
#include <iostream>

using namespace std;

int m,n,k;

int find (int X[], int m, int Y[], int n, int k) {
    int temp = 0, xBeg = 0, xEnd = 0, yBeg = 0, yEnd = 0, xMid = 0, yMid = 0;
    xBeg = yBeg = 0;
    xEnd  = m - 1;
    yEnd = n - 1;
    
    while (xBeg <= xEnd && yBeg <= yEnd) {
        xMid = (xBeg + xEnd) /2;
        yMid = (yBeg + yEnd) /2;
        
        temp = (xMid - xBeg + 1) + (yMid - yBeg + 1);
        
        if(X[xMid] > Y[yMid]) {
            if(temp > k) {
                xEnd = xMid - 1;
            }
            else {
                k = k - (yMid - yBeg + 1);
                yBeg = yMid + 1;
            }
        } else {
            if(temp > k) {
                yEnd = yMid - 1;
            } else {
                k = k - (xMid - xBeg + 1);
                xBeg = xMid + 1;
            }
        }
    }
    
    if(xBeg > xEnd) {
        return Y[yBeg + k - 1];
    }
    else {
        return X[xBeg + k - 1];
    }
}

int main(int argc, const char * argv[]) {
    
    cin >> m;
    cin >> n;
    cin >> k;
    
    int X[m];
    int Y[n];
    
    for (int i = 0; i < m; i++) {
        cin >> X[i];
    }
    
    for (int i = 0; i < n; i++) {
        cin >> Y[i];
    }
    
    cout << find(X, m, Y, n, k) << endl;
}
    </pre>
  </div>

  <div>
    <h3>8596 最长上升子序列</h3>
    <pre style="display: none;">
#include<iostream>

using namespace std;

int n;
int a[501];

int f[501];
int c[100];
int num=0;

int main()
{
    while(true)
    {
        a[0]=-1;
        cin >>n;
        if(n==0)
            break;                             //输入停止条件
        
        for(int i=1; i<=n; i++)
            cin>>a[i];
        
        for(int i=1; i<=n; i++)
        {
            f[i]=1;                           //初始化，单个元素作为一个队列时，长度都为1
            int big=0;
            for(int j=1; j< i; j++)
                if(a[j]< a[i])
                    if(big< f[j])
                        big=f[j];            //找出a[i]之前的字串中比a[i]值小且其递增子串队列长度最大的队列，
            //将子串队列长度赋值给big
            
            f[i]=big+1;                //big为找到的最优子串的长度，+1是加上a[i]本身长度
        }
        int max=f[1];
        //数组f中已经存放数组a的不同递增子串长度，遍历数组f，找出最大值
        for(int i=1; i<=n; i++)
            if(max< f[i])
                max=f[i];
        c[num++]=max;
        
    }
    for(int i=0; i< num; i++)
        cout << c[i]<< endl;
}
    </pre>
  </div>

  <div>
    <h3>8601 最大长方体问题</h3>
    <pre style="display: none;">
#include<iostream>

using namespace std;

int max(int i,int j)
{
    if(i>=j)
        return i;
    else
        return j;
}

int MSum(int *a,int n)
{
    int sum=0;
    int b[50];
    b[0]=a[0];
    for(int i=1;i< n;i++)
    {
        b[i]=max(b[i-1]+a[i],a[i]);
        if(b[i]>sum)
            sum=b[i];
    }
    return sum;
}

int MSum2(int a[][50],int m,int n)
{
    int sum=0;
    int b[50],k;
    for(int i=0;i< m;i++)
    {
        for(k=0;k< n;k++)
            b[k]=0;
        for(int j=i;j< m;j++)
        {
            for(k=0;k< n;k++)
                b[k]+=a[j][k];
            sum=max(sum,MSum(b,n));
        }
    }
    return sum;
}

int MSum3(int a[][50][50],int m,int n,int p)
{
    int sum=0;
    int b[50][50],k,i,j,z,x;
    for(i=0;i< p;i++)
    {
        for(z=0;z< m;z++)
            for(x=0;x< n;x++)
                b[z][x]=0;
        
        for(int j=i;j< p;j++)
        {
            for(z=0;z< m;z++)
                for(x=0;x< n;x++)
                    b[z][x]+=a[z][x][j];
            sum=max(sum,MSum2(b,m,n));
        }
    }
    return sum;
}


int main()
{
    int a[50][50][50],m,n,p;
    cin>>m>>n>>p;
    for(int i=0;i< m;i++)
        for(int j=0;j< n;j++)
            for(int k=0;k< p;k++)
                cin>>a[i][j][k];
    cout<< MSum3(a,m,n,p)<< endl;
    
    return 0;
}
    </pre>
  </div>

  <div>
    <h3>10303 数字三角</h3>
    <pre style="display: none;">

    </pre>
  </div>

  <div>
    <h3>11077 最长公共子字符串</h3>
    <pre style="display: none;">

    </pre>
  </div>

  <script>
  (function () {
    var titles = document.getElementsByTagName('h3');
    var codes = document.getElementsByTagName('pre');

    for (var i = 0; i < titles.length; i++) {
      (function () {
        var j = i;
        titles[j].onclick = function (e) {
          if (codes[j].style.display == 'none') {
            codes[j].style.display = 'block';
          } else {
            codes[j].style.display = 'none';
          }
        }
      })();
    }

    for (var i = 0; i < codes.length; i++) {
      (function () {
        var j = i;
        codes[j].ondblclick = function (e) {
          codes[j].style.display = 'none';
        }
      })();
    }
  })();
  </script>

</body>
</html>